#!/bin/bash

###############################################################################
# Used to build the configuration files from the user provided inputs
#
# docker-compose does not easily provide a way to propagate high-level
# configuration to combine multiple env files, so this script is used to do it.
#
# The general idea is to inject variables defined in env.custom in env.base
# in order to generate a ".env" file aggregating everything.
#
# By default, all services are enabled. Dpecific (unused) services can be
# disabled by adding them to the "disabled_services" file
###############################################################################
set -euo pipefail

export BASE_PATH=`realpath "$(dirname $0)/.."`
. "${BASE_PATH}/bin/helpers/colors.sh"

if [[ -f "$BASE_PATH/env.custom" ]]; then
    echo Will load "$BASE_PATH"/env.custom
fi
if [[ -f "$BASE_PATH/custom/env.custom" ]]; then
    echo Will load "$BASE_PATH"/custom/env.custom
elif [[ ! -f "$BASE_PATH/env.custom" ]]; then
    >&2 echo "env.custom should be configured either at the root of the project"
    >&2 echo "or in the custom repository"
    exit 1
fi

if [[ -f "$BASE_PATH/disabled_services" ]]; then
    echo Will load "$BASE_PATH"/disabled_services
fi

if [[ -f "$BASE_PATH/custom/disabled_services" ]]; then
    echo Will load "$BASE_PATH"/custom/disabled_services
fi
echo ""

generate () {
    # We want that variables defined in sub-files to be available in this
    # process
    set -o allexport

    # Load configuration value from custom folder first, in case the local
    # env.custom wants to override it
    if [[ -f "$BASE_PATH/custom/env.custom" ]]; then
        . "$BASE_PATH/custom/env.custom"
    fi

    # Load custom values
    if [[ -f "$BASE_PATH/env.custom" ]]; then
        . "$BASE_PATH/env.custom"
    fi

    # Load base values, applying modifications based on previously loaded
    # (env.custom) values
    . "$BASE_PATH/env.base"

    # A little intimdating, but what is actually done here is looking for all
    # the variables defined in env.base or env.custom, and printing them to
    # stdout with their value. This is what will actually be stored in the .env
    # file
    for i in $( \
            (cat "$BASE_PATH/env.base" \
                && ( \
                    ([[ -f "$BASE_PATH/env.custom" ]] && \
                        cat "$BASE_PATH/env.custom") \
                    || echo "") \
                && ( \
                    ([[ -f "$BASE_PATH/custom/env.custom" ]] && \
                        cat "$BASE_PATH/custom/env.custom") \
                    || echo "") \
                ) \
            | grep -v "^ *#" | grep -v "^$" | sed -e "s/^\([A-Z0-9_]*\)=.*/\1/" \
            | sort -u); do
        echo "$i="$(env | grep "^$i=" | sed -e "s/^[A-Z0-9_]*=\(.*\)/\1/")
    done
}

set_services () {
    # Create the list of services to include in the docker-compose project.
    #
    # By default, all services from the "compose" folder are loaded, with the
    # exception of back/common which is a template for building back-office
    # services and does not exist as such.
    #
    # Services in "disabled_services" will also be removed
    SERVICES="docker-compose.yml"

    shopt -s nullglob
    for path in $(cd $BASE_PATH && ls compose/**/*.yml custom/compose/**/*.yml); do
        # Remove the "custom/", "compose/" and the ".yml"
        key=${path#*compose/}
        service=${key%.yml}

        if [[ "$service" = "back/common" ]]; then
            continue
        fi
        if [[ -f "$BASE_PATH/disabled_services" ]] && \
                cat $BASE_PATH/disabled_services | grep -v "^#" | \
                grep -E "^$service$" > /dev/null; then
            fail "Ignoring $service"
        elif [[ -f "$BASE_PATH/custom/disabled_services" ]] && \
                cat $BASE_PATH/custom/disabled_services | grep -v "^#" | \
                grep -E "^$service$" > /dev/null; then
            fail "Ignoring $service"
        else
            check "Adding $service"
        fi
    done
    shopt -u nullglob

    if [[ -f "$BASE_PATH"/custom/override.yml ]]; then
        SERVICES="$SERVICES:custom/override.yml"
    fi

    if [[ -f "$BASE_PATH"/override.yml ]]; then
        SERVICES="$SERVICES:override.yml"
    fi

    echo "COMPOSE_FILE=$SERVICES" >> "$BASE_PATH/.env"
}

init_service_env_files () {
    # Create env files for all services if needed
    mkdir -p "$BASE_PATH"/env

    for f in $(ls "$BASE_PATH"/defaults/env); do
        if [[ ! -e "$BASE_PATH/env/$f" ]]; then
            cp "$BASE_PATH"/defaults/env/"$f" "$BASE_PATH"/env/"$f"
        fi
    done
}

check_host_integration() {
    filename="$BASE_PATH/docker-compose.host-integration.yaml"

    if [[ -f "$BASE_PATH/custom/env.custom" ]]; then
        . "$BASE_PATH/custom/env.custom"
    fi

    # Load custom values
    if [[ -f "$BASE_PATH/env.custom" ]]; then
        . "$BASE_PATH/env.custom"
    fi

    if [[ "${ENABLE_HOST_NETWORK_INTEGRATION:-}" = "1" ]]; then
        echo ""
        echo "Warning: Host network integration enabled"

        echo "services:" > "$filename"
        for service in $(docker-compose config | yq -r '.services | keys[]'); do
            echo "  $service:" >> "$filename"
            echo "    extra_hosts:" >> "$filename"
            echo '      - "host.docker.internal:host-gateway"' >> "$filename"
        done

        sed -i "s/^\\(COMPOSE_FILE=.*\\)/\\1:docker-compose.host-integration.yaml/" "$BASE_PATH/.env"
    else
        rm -f "$filename"
    fi
}

check_configuration() {
    . "$BASE_PATH/.env"

    # Check for variables that are not required for compatibility, but are
    # strongly recommended :)
    if [[ "$COOG_PASSPHRASE" = "" ]]; then
        warning "COOG_PASSPHRASE should not be empty in a production environment"
    fi
}

section "Updating .env contents"
echo "# AUTO GENERATED, DO NOT MODIFY MANUALLY" > "$BASE_PATH/.env"

# We must run this in a sub-process because it modifies the environment
(generate) >> "$BASE_PATH/.env"
set_services
init_service_env_files
(check_host_integration)
(check_configuration)
echo " "
