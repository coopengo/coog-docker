#!/bin/bash
###############################################################################
# Toolkit for environment management
#
# See README file, or --help for more details
###############################################################################
set -euo pipefail

BASE_PATH=$(realpath "$(dirname $0)/..")
. "${BASE_PATH}/bin/helpers/colors.sh"
. "${BASE_PATH}/bin/helpers/docker-compose"

help() {
    echo "manage_db - Manage database"
    echo " "
    echo "manage_db action [options] [arguments]"
    echo " "
    echo "actions:"
    echo "  help                        Show this help"
    echo "  reset                       Clear (or init) the database"
    echo "  load <file_name>            Load database from file on postgres"
    echo "  dump <file_name>            Dump the current database for safekeeping on postgres"
    echo "  dump_all                    Dump all 'no system' databases on postgres"
    echo "  mongo_dump                  Dump all mongodb databases"
    echo "  mongo_restore <file_name>   Restore mongodb backup"
    echo "  update [modules]            Force an update of the database"
    echo "  change_admin_password       Change the admin password of the database"
    echo "  anonymize [level]           Anonymize the database"
    echo " "
    echo "options:"
    echo "--database <db_name>        The database to operate on"
    echo "--format <format>           The format to load from / dump database dumps."
    echo "                            For postgreSQL: sql(default),bin,zip,tar.gz"
    echo "                            For MongoDB: default,zip,tar.gz"
}

if [[ "$#" -lt 1 ]]; then
    echo "Missing action" >&2
    help
    exit 1
fi

reset() {
    if [[ "${USE_LOCAL_POSTGRES}" = "1" ]]; then
        _start_services postgres
    fi
    _reset_database
    update
}

load() {
    dump_file=$1

    if [[ "${USE_LOCAL_POSTGRES}" = "0" ]]; then
        echo Cannot use load command for non dockerized database 1>&2
        exit 1
    fi
    _start_services postgres
    _db_wait
    sleep 20
    _reset_database
    _db_wait

    echo " "
    section "Loading database from dump file"

    format="${format:-sql}"
    if [[ "${dump_file}" =~ (.*).postgresql.zip$ ]]; then
        unzip -p "${dump_file}" >/tmp/tmp_extracted_dump
        format=sql
        dump_file=/tmp/tmp_extracted_dump
    elif [[ "${dump_file}" =~ (.*).postgresql.tar.gz$ ]]; then
        tar -xvzf "${dump_file}" -C /tmp/
        format=sql
        dump_file="/tmp/$(tar -tzf ${dump_file} | head -1)"
    fi

    ${DOCKER_COMMAND} cp "${dump_file}" postgres:/tmp/dump

    if [[ "${format}" = "sql" ]]; then
        ${DOCKER_COMMAND} exec -T -- postgres \
            bash -c "cat /tmp/dump | psql -U ${db_user} -d ${db_name}" \
            >/dev/null
    else
        ${DOCKER_COMMAND} exec -T -- postgres \
            pg_restore -U "${db_user}" --no-owner --role "${db_user}" -j 4 \
            -d "${db_name}" /tmp/dump
    fi
    ${DOCKER_COMMAND} exec -T -- postgres rm "/tmp/dump"

    echo " "
    section "Loading database done."
}

_mongo_dump() {
    echo " "
    if [[ "${USE_LOCAL_POSTGRES}" = "0" ]]; then
        echo Cannot use dump command for non dockerized database 1>&2
        exit 1
    fi

    _start_services mongo

    sleep 5

    dump_file="${1:-/tmp/full-backup-$(date '+%Y-%m-%d').mongodb}"
    MONGODB_DATA_PATH="$(source "${BASE_PATH}/.env" && echo ${MONGODB_DATA_VOLUME})"

    ${DOCKER_COMMAND} exec mongo mongodump -u "$(source "${BASE_PATH}/.env" && echo ${MONGO_USER})" -p "$(source "${BASE_PATH}/.env" && echo ${MONGO_PASSWORD})" -o "/data/db/tmp_backup"

    if [[ "${format}" = "default" ]]; then
        mv "${MONGODB_DATA_PATH}/tmp_backup" "${dump_file}"
    elif [[ "${format}" = "tar.gz" ]]; then
        tar -cvzf "${dump_file}.tar.gz" "${MONGODB_DATA_PATH}/tmp_backup"
        rm "${MONGODB_DATA_PATH}/tmp_backup"
    elif [[ "${format}" = "zip" ]]; then
        zip -r "${dump_file}.zip" "${MONGODB_DATA_PATH}/tmp_backup"
        rm "${MONGODB_DATA_PATH}/tmp_backup"
    fi

    echo "The MongoDB backup is available on ${dump_file} path"
}

_mongo_restore() {
    dump_file="$1"

    if [[ ! "${dump_file}" =~ (.*).mongodb(zip|.tar.gz)$ ]]; then
        echo "No good format found."
        echo "File / Directory must end with .mongodb (directory), .mongodb.zip or .mongodb.tar.gz"
        exit 1
    fi

    if [[ "${dump_file}" =~ (.*).mongodb.zip$ ]]; then
        MONGODB_UNCOMPRESS_DIR="$(unzip -qql "${dump_file}" | head -n1 | tr -s ' ' | cut -d' ' -f5-)"
        unzip "${dump_file}"
    elif [[ "${dump_file}" =~ (.*).mongodb.tar.gz$  ]]; then
        MONGODB_UNCOMPRESS_DIR="$(tar -tzf "${dump_file}" | head -1 | cut -f1 -d "/")"
        tar -xvzf "${dump_file}"
    fi

    ${DOCKER_COMMAND} exec mongo mongorestore -u "$(source "$BASE_PATH/.env" && echo $MONGO_USER)" -p "$(source "$BASE_PATH/.env" && echo $MONGO_PASSWORD)" "${MONGODB_UNCOMPRESS_DIR:-${dump_file}}"

    if [[ -n "${MONGODB_UNCOMPRESS_DIR}" ]]; then
        rm -rf "${MONGODB_UNCOMPRESS_DIR}"
    fi
}

dump_all() {
    _start_services postgres

    sleep 5

    format="${format:-sql}"
    dump_file="${1:-/tmp/full-backup-$(date '+%Y-%m-%d').postgresql}"

    section "Dumping all no-system databases to ${dump_file} (format ${format})"

    ${DOCKER_COMMAND} exec -T -- postgres bash -c "pg_dumpall --no-owner -U ${db_user} --exclude-database=\"postgres|template0|template1\" > /tmp/dump" >/dev/null
    ${DOCKER_COMMAND} cp postgres:/tmp/dump "${dump_file}.sql"
    ${DOCKER_COMMAND} exec -T -- postgres rm -rf "/tmp/dump"

    if [[ "${format}" = "tar.gz" ]]; then
        ARCHIVE_FILE="${dump_file##*/}"
        ARCHIVE_DIR="${dump_file%$ARCHIVE_FILE}"

        tar -cvzf "${dump_file}.tar.gz" -C "${ARCHIVE_DIR}" "${ARCHIVE_FILE}.sql"
        rm "${dump_file}.sql"
    elif [[ "${format}" = "zip" ]]; then
        ARCHIVE_FILE="${dump_file##*/}"
        ARCHIVE_DIR="${dump_file%$ARCHIVE_FILE}"

        (cd "${ARCHIVE_DIR}" && zip -r "${dump_file}.zip" "${ARCHIVE_FILE}.sql")
        rm "${dump_file}.sql"
    fi
}

dump() {
    echo " "
    if [[ "${USE_LOCAL_POSTGRES}" = "0" ]]; then
        echo Cannot use dump command for non dockerized database 1>&2
        exit 1
    fi

    _start_services postgres

    sleep 5

    format="${format:-sql}"
    dump_file="${1:-/tmp/${db_name}-$(date '+%Y-%m-%d').postgresql}"

    section "Dumping database ${db_name} to ${dump_file} (format ${format})"

    if [[ "${format}" =~ ^(sql|zip|tar.gz)$ ]]; then
        ${DOCKER_COMMAND} exec -T -- postgres bash -c "pg_dump -U ${db_user} ${db_name} > /tmp/dump" >/dev/null
    else
        ${DOCKER_COMMAND} exec -T -- postgres pg_dump -U "${db_user}" -d "${db_name}" -Fc -Z5 -f /tmp/dump >/dev/null
    fi
    ${DOCKER_COMMAND} cp postgres:/tmp/dump "${dump_file}.sql"
    ${DOCKER_COMMAND} exec -T -- postgres rm "/tmp/dump"

    if [[ "${format}" = "tar.gz" ]]; then
        ARCHIVE_FILE="${dump_file##*/}"
        ARCHIVE_DIR="${dump_file%$ARCHIVE_FILE}"

        tar -cvzf "${dump_file}.tar.gz" -C "${ARCHIVE_DIR}" "${ARCHIVE_FILE}.sql"
        rm "${dump_file}.sql"
    elif [[ "${format}" = "zip" ]]; then
        ARCHIVE_FILE="${dump_file##*/}"
        ARCHIVE_DIR="${dump_file%$ARCHIVE_FILE}"

        (cd "${ARCHIVE_DIR}" && zip -r "${dump_file}.zip" "${ARCHIVE_FILE}.sql")
        rm "${dump_file}.sql"
    fi
}

update() {
    if [[ "${USE_LOCAL_POSTGRES}" = "1" ]]; then
        _start_services postgres
    fi
    _start_services coog

    # Workaround due to some performance issues on Macos (and Windows). These are related to volume performance, the way volumes are mounted, and the underlying osx/windows filesystem.
    sleep 1
    # We need to kill the "init" container because it may lead to deadlocks.
    # And we are updating the db anyaway
    ${DOCKER_COMMAND} rm -s -f init >/dev/null

    if [[ "$#" = "0" ]]; then
        args=ir
    else
        args=$*
    fi
    ${DOCKER_COMMAND} exec -T -- coog ep admin -d "${db_name}" --activate-dependencies -u "${args}"
}

change_admin_password() {
    if [[ "${USE_LOCAL_POSTGRES}" = "1" ]]; then
        _start_services postgres
    fi
    _start_services coog

    # We need to kill the "init" container because it is started automatically,
    # and we do not need since the DB is supposed to already be up to date
    sleep 1
    ${DOCKER_COMMAND} rm -s -f init >/dev/null

    ${DOCKER_COMMAND} exec -T -- coog ep admin -d "${db_name}" -p
}

anonymize() {
    echo " "

    if [[ "${USE_LOCAL_POSTGRES}" = "0" ]]; then
        echo Cannot use anonymize command for non dockerized database 1>&2
        exit 1
    fi
    _start_services postgres

    ${DOCKER_COMMAND} cp "$BASE_PATH/bin/resources/anonymize_coog_db.sql" postgres:/tmp/anonymize.sql

    ${DOCKER_COMMAND} exec -T -- postgres psql -U "${db_user}" -d "${db_name}" \
        --file /tmp/anonymize.sql
}

_load_configuration() {
    "${BASE_PATH}/bin/configure"

    section "Loading required informations"

    project_name=$(source "$BASE_PATH/.env" && echo $COMPOSE_PROJECT_NAME)
    if [[ ! "$project_name" ]]; then
        echo "Could not extract compose project name from .env file"
        exit 1
    else
        echo "Project name: $project_name"
    fi

    if [[ "${db_name:-not_set}" = "not_set" ]]; then
        db_name=$(source "$BASE_PATH/.env" && echo $COOG_MAIN_DATABASE)
        if [[ ! "${db_name}" ]]; then
            echo "Could not extract database name from .env file"
            exit 1
        else
            echo "Target database: ${db_name}"
        fi
    else
        echo "Target database: ${db_name}"
    fi

    db_user=$(source "$BASE_PATH/.env" && echo $POSTGRES_USER)
    if [[ ! "${db_user}" ]]; then
        echo "Could not extract user name from .env file"
        exit 1
    else
        echo "Database user: ${db_user}"
    fi

    POSTGRES_HOST=$(. "$BASE_PATH/.env" && echo $POSTGRES_HOST)
    [[ "$POSTGRES_HOST" = "postgres" ]] && USE_LOCAL_POSTGRES=1 ||
        USE_LOCAL_POSTGRES=0

    echo " "
}

_stop_everything() {
    section "Stopping everything"
    (cd "$BASE_PATH" && ${DOCKER_COMMAND} down)
}

_start_services() {
    echo " "
    section "Starting services $*"
    (cd "$BASE_PATH" && ${DOCKER_COMMAND} up -d $*)
}

_reset_database() {
    if [[ "${USE_LOCAL_POSTGRES}" = "0" ]]; then
        echo Cannot reset database for non dockerized database 1>&2
        exit 1
    fi

    echo " "
    section "Dropping existing database"
    ${DOCKER_COMMAND} exec -T -- postgres dropdb -U "${db_user}" --if-exists "${db_name}"

    echo " "
    section "Recreating database"
    ${DOCKER_COMMAND} exec -T -- postgres createdb -U "${db_user}" "${db_name}"
}

_restart() {
    echo " "
    (cd "$BASE_PATH" && ${DOCKER_COMMAND} up -d)
}

_db_wait() {
    DB_RETRIES=30

    until ${DOCKER_COMMAND} exec -T -- postgres pg_isready -U "${db_user}" || [[ ${DB_RETRIES} -eq 0 ]]; do
        echo "Waiting for postgres server, $((DB_RETRIES--)) remaining attempts..."
        sleep 5
    done
}

command=$1
shift

while test $# -gt 0; do
    case "$1" in
    --database)
        shift
        db_name=$1
        shift
        ;;
    --format)
        shift
        format=$1
        if [[ ! "${format}" =~ ^(sql|bin|zip|tar.gz)$ ]]; then
            echo "Invalid file format ${format}" >&2
            help
            exit 1
        fi
        shift
        ;;
    *)
        break
        ;;
    esac
done

case "$command" in
help)
    help
    exit 0
    ;;
reset)
    _load_configuration
    _stop_everything
    reset $*
    _restart
    ;;
load)
    _load_configuration
    _stop_everything
    load $*
    _restart
    ;;
dump)
    _load_configuration
    dump $*
    ;;
dump_all)
    _load_configuration
    dump_all $*
    ;;
mongodb_dump)
    _mongo_dump "$@"
    ;;
mongodb_restore)
    _mongo_restore "$@"
    ;;
update)
    _load_configuration
    _stop_everything
    update $*
    _restart
    ;;
change_admin_password)
    _load_configuration
    change_admin_password $*
    ;;
anonymize)
    _load_configuration
    anonymize $*
    ;;
*)
    echo "Invalid action" >&2
    help
    exit 1
    ;;
esac
