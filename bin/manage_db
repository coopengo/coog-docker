#!/bin/bash
###############################################################################
# Toolkit for environment management
#
# See README file, or --help for more details
###############################################################################
set -euo pipefail

BASE_PATH=$(realpath "$(dirname "${0}")/..")
. "${BASE_PATH}/bin/helpers/colors.sh"
. "${BASE_PATH}/bin/helpers/docker-compose"

help() {
    echo "manage_db - Manage database"
    echo " "
    echo "manage_db action [options] [arguments]"
    echo " "
    echo "actions:"
    echo "  help                      Show this help"
    echo "  reset                     Clear (or init) the database"
    echo "  load <file_name>.zip      Load database from file"
    echo "  dump <file_name>          Dump the current database for safekeeping"
    echo "  update [modules]          Force an update of the database"
    echo "  change_admin_password     Change the admin password of the database"
    echo "  anonymize [level]         Anonymize the database"
    echo " "
    echo "options:"
    echo "--db-type <(coog or strapi)>        Type of database to operate (default: coog)"
    echo "--database <db_name>                The database to operate on"
    echo "--format <(sql or bin)>             The format to load from / dump database dumps (default: sql)"
}

if [[ "$#" -lt 1 ]]; then
    echo "Missing action" >&2
    help
    exit 1
fi

reset() {
    if [[ "${USE_LOCAL_POSTGRES}" = "1" ]]; then
        _start_services postgres
    fi
    _reset_database
    update
}

load() {
    dump_file="${1:-/tmp/postgres-${DB_TYPE}-$(date '+%Y-%m-%d')}.zip"

    if [[ "${USE_LOCAL_POSTGRES}" = "0" ]]; then
        echo "Cannot use load command for non-dockerized database" >&2
        exit 1
    fi

    if [[ ! "${dump_file}" =~ (.*).zip$ ]]; then
        printf "\033[1;31m%s\033[0m" "The file must be compressed in zip format."
        exit 1
    fi

    _start_services postgres
    _db_wait
    sleep 20
    _reset_database
    _db_wait

    echo " "
    section "Loading PostgreSQL database from ${dump_file}"

    POSTGRES_UNCOMPRESS_DIR="$(unzip -qql "${dump_file}" | head -n1 | tr -s ' ' | cut -d' ' -f5-)"
    unzip "${dump_file}"

    # Copy the dump file to the Docker container
    ${DOCKER_COMMAND} cp "${dump_file/%zip/${format}}" postgres:/tmp/dump

    if [[ "${POSTGRES_UNCOMPRESS_DIR}" =~ (.*).sql$  ]]; then
        # Restore SQL dump using psql
        ${DOCKER_COMMAND} exec -T --user postgres postgres \
            bash -c "cat /tmp/dump | psql -U ${db_user} -d ${db_name}" \
            >/dev/null
    else
        # Restore binary dump using pg_restore
        ${DOCKER_COMMAND} exec -T --user postgres postgres \
            pg_restore -U "${db_user}" --no-owner --role "${db_user}" -j 4 \
            -d "${db_name}" /tmp/dump
    fi

    # Remove the dump file from the Docker container
    ${DOCKER_COMMAND} exec -T --user postgres postgres rm "/tmp/dump"

    echo " "
    section "Loading database done."
}

dump() {
    echo " "
    if [[ "${USE_LOCAL_POSTGRES}" = "0" ]]; then
        echo Cannot use dump command for non dockerized database 1>&2
        exit 1
    fi

    _start_services postgres

    dump_file="${1:-/tmp/postgres-${DB_TYPE}-$(date '+%Y-%m-%d')}.${format}"

    section "Dumping PostgreSQL database ${db_name} in ${dump_file}."

    if [[ "${format}" = "sql" ]]; then
        ${DOCKER_COMMAND} exec -T -- postgres bash -c "pg_dump -U ${db_user} ${db_name} > /tmp/dump" >/dev/null
    else
        ${DOCKER_COMMAND} exec -T -- postgres pg_dump -U "${db_user}" -d "${db_name}" -Fc -Z5 -f /tmp/dump >/dev/null
    fi

    ${DOCKER_COMMAND} cp postgres:/tmp/dump "${dump_file}"
    ${DOCKER_COMMAND} exec -T -- postgres rm "/tmp/dump"

    echo "Compressing database..."
    zip "${dump_file/%${format}/zip}" "${dump_file}"
    rm "${dump_file}"
    echo "Compression complete"
}

update() {
    if [[ "${USE_LOCAL_POSTGRES}" = "1" ]]; then
        _start_services postgres
    fi
    _start_services coog

    # Workaround due to some performance issues on Macos (and Windows). These are related to volume performance, the way volumes are mounted, and the underlying osx/windows filesystem.
    sleep 1
    # We need to kill the "init" container because it may lead to deadlocks.
    # And we are updating the db anyaway
    ${DOCKER_COMMAND} rm -s -f init >/dev/null

    if [[ "$#" = "0" ]]; then
        args=ir
    else
        args=$*
    fi
    ${DOCKER_COMMAND} exec -T -- coog ep admin -d "${db_name}" --activate-dependencies -u $args
}

change_admin_password() {
    if [[ "${USE_LOCAL_POSTGRES}" = "1" ]]; then
        _start_services postgres
    fi
    _start_services coog

    # We need to kill the "init" container because it is started automatically,
    # and we do not need since the DB is supposed to already be up to date
    sleep 1
    ${DOCKER_COMMAND} rm -s -f init >/dev/null

    ${DOCKER_COMMAND} exec -T -- coog ep admin -d "${db_name}" -p
}

anonymize() {
    echo " "

    if [[ "${USE_LOCAL_POSTGRES}" = "0" ]]; then
        echo Cannot use anonymize command for non dockerized database 1>&2
        exit 1
    fi
    _start_services postgres

    ${DOCKER_COMMAND} cp "${BASE_PATH}/bin/resources/anonymize_coog_db.sql" postgres:/tmp/anonymize.sql

    ${DOCKER_COMMAND} exec -T -- postgres psql -U "${db_user}" -d "${db_name}" \
        --file /tmp/anonymize.sql
}

_load_configuration() {
    "${BASE_PATH}/bin/configure"

    section "Loading required informations"

    project_name=$(source "${BASE_PATH}/.env" && echo "${COMPOSE_PROJECT_NAME}")
    if [[ -z "${project_name}" ]]; then
        echo "Could not extract compose project name from .env file"
        exit 1
    else
        echo "Project name: ${project_name}"
    fi

    db_user=$(source "${BASE_PATH}/.env" && echo "${POSTGRES_USER}")
    if [[ -z "${db_user}" ]]; then
        echo "Could not extract user name from .env file"
        exit 1
    else
        echo "Database user: ${db_user}"
    fi

    POSTGRES_HOST=$(. "${BASE_PATH}/.env" && echo "${POSTGRES_HOST}")
    [[ "${POSTGRES_HOST}" = "postgres" ]] && USE_LOCAL_POSTGRES=1 ||
        USE_LOCAL_POSTGRES=0

    echo " "
}

_stop_everything() {
    section "Stopping everything"
    (cd "${BASE_PATH}" && ${DOCKER_COMMAND} down)
}

_start_services() {
    echo " "
    section "Starting services $*"
    (cd "${BASE_PATH}" && ${DOCKER_COMMAND} up -d $*)
}

_reset_database() {
    if [[ "${USE_LOCAL_POSTGRES}" = "0" ]]; then
        echo Cannot reset database for non dockerized database 1>&2
        exit 1
    fi

    echo " "
    _db_wait
    section "Dropping existing database"
    ${DOCKER_COMMAND} exec -T -- postgres dropdb -U "${db_user}" --if-exists "${db_name}"

    echo " "
    section "Recreating database"
    ${DOCKER_COMMAND} exec -T -- postgres createdb -U "${db_user}" "${db_name}"
}

_restart() {
    echo " "
    (cd "${BASE_PATH}" && ${DOCKER_COMMAND} up -d)
}

_db_wait() {
    DB_RETRIES=30

    until ${DOCKER_COMMAND} exec -T -- postgres pg_isready -U "${db_user}" || [[ ${DB_RETRIES} -eq 0 ]]; do
        echo "Waiting for postgres server, $((DB_RETRIES--)) remaining attempts..."
        sleep 5
    done
}

command="${1}"
shift

while test $# -gt 0; do
    case "$1" in
    --db-type)
        shift
        DB_TYPE="${1:-coog}"
        if [[ ! "${DB_TYPE}" =~ ^(coog|strapi)$ ]]; then
            help
            printf "\033[1;31m%s\033[0m" "The --db-type option must be coog (default) or strapi."
            exit 1
        fi
        shift
        ;;
    --database)
        shift
        db_name="${1}"
        if [[ -z "${db_name}" ]]; then
            if [[ "${DB_TYPE}" == "coog" ]]; then
                db_name=$(source "${BASE_PATH}/.env" && echo "${COOG_MAIN_DATABASE}")
            elif [[ "${DB_TYPE}" == "strapi" ]]; then
                db_name=$(source "${BASE_PATH}/.env" && echo "${POSTGRES_B2C_DB}")
            fi
            if [[ -z "${db_name}" ]]; then
                echo "Could not extract database name from .env file"
                exit 1
            else
                echo "Target database: ${db_name}"
            fi
        else
            echo "Target database: ${db_name}"
        fi
        shift
        ;;
    --format)
        shift
        format="${1:-sql}"
        if [[ ! "${format}" =~ ^(sql|bin)$ ]]; then
            help
            printf "\033[1;31m%s\033[0m" "The --format option must be sql (default) or bin."
            exit 1
        fi
        shift
        ;;
    *)
        break
        ;;
    esac
done

case "${command}" in
help)
    help
    exit 0
    ;;
reset)
    _load_configuration
    _stop_everything
    reset "$@"
    _restart
    ;;
load)
    _load_configuration
    _stop_everything
    load "$@"
    _restart
    ;;
dump)
    _load_configuration
    dump "$@"
    ;;
update)
    _load_configuration
    _stop_everything
    update "$@"
    _restart
    ;;
change_admin_password)
    _load_configuration
    change_admin_password "$@"
    ;;
anonymize)
    _load_configuration
    anonymize "$@"
    ;;
*)
    echo "Invalid action" >&2
    help
    exit 1
    ;;
esac
